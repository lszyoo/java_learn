#!/user/bin/env python3
# -*- coding: utf-8 -*-

# 在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数
# 理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。

# n！
def fact(n):
    if n==1:
        return 1
    return n * fact(n-1)

print(fact(5))
# 输出：120


# 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，
# 每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

# fact(1000)    # RecursionError: maximum recursion depth exceeded in comparison


# 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

# 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，
# 使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

def fact_modify(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
# 仅返回递归函数本身，在函数调用前就会被计算，不影响函数调用。


# 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。
# 遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。



# 汉诺塔移动
# 有三根杆子A，B，C。A杆上有N个(N>1)穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆：
# 1.每次只能移动一个圆盘.
# 2.大盘不能叠在小盘上面.
# 思路: 这个问题可以分解成三步，假设A杆上有n个盘，第一步把A杆上面的n-1个盘移动到B杆；第二步，那么就剩最后也是最大的那一个盘，
#      我们就把它直接从A杆移动到C杆；第三步，把剩下的n-1个盘从B杆移动到C杆。
def move(n, a, b, c):           # 注意本例用到的是 整体思维
    if n == 1:
        print('move', a, '-->', c)
    else:
        move(n - 1, a, c, b)    # 将 n-1 个从a借助c挪到b上
        move(1, a, b, c)        # 将 a上最大的那个挪到c上
        move(n - 1, b, a, c)    # 将 n-1 个从b借助a挪到c上


move(3, 'A', 'B', 'C')